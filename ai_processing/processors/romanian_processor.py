#!/usr/bin/env python3
"""
Romanian Subsidy Processor
==========================

Specialized AI processor for Romanian agricultural subsidies with
PNDR-specific intelligence and Romanian language optimization.
"""

import logging
from typing import Dict, List, Any, Optional
import re

from .base_processor import BaseProcessor


class RomanianProcessor(BaseProcessor):
    """
    Romanian-specific AI processor for subsidy data extraction.
    
    Optimized for:
    - Romanian language and diacritics
    - PNDR (National Rural Development Program) structure
    - Romanian administrative divisions (jude»õe)
    - RON to EUR currency conversion
    - Romanian agricultural terminology
    """
    
    def __init__(self, config):
        """Initialize Romanian processor."""
        super().__init__(config)
        self.logger = logging.getLogger(__name__)
        
        # Romanian-specific patterns and mappings
        self.county_mappings = self._initialize_county_mappings()
        self.pndr_measure_codes = self._initialize_pndr_codes()
        self.romanian_terms = self._initialize_romanian_terms()
        
        # Currency conversion (simplified - would use real API)
        self.ron_to_eur_rate = 0.20  # Approximate rate
    
    async def extract_subsidy_data(
        self, 
        content: Dict[str, Any], 
        documents: List[Any], 
        metadata: Dict[str, Any],
        analysis: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Extract subsidy data with Romanian-specific intelligence."""
        try:
            self.logger.info("üá∑üá¥ Processing Romanian subsidy content")
            
            text_content = content.get('text_content', '')
            
            # Extract core information
            extraction = {
                'title': self._extract_romanian_title(text_content),
                'description': self._extract_description(text_content),
                'financial_info': self._extract_financial_info(text_content),
                'eligibility': self._extract_eligibility_criteria(text_content),
                'deadlines': self._extract_deadlines(text_content),
                'geographic_scope': self._extract_geographic_scope(text_content),
                'documents': self._extract_document_requirements(text_content, documents),
                'pndr_info': self._extract_pndr_specific_info(text_content),
                'contact_info': self._extract_contact_information(text_content),
                'country': 'romania',
                'language': 'ro'
            }
            
            # Enhance with document analysis
            if documents:
                extraction = await self._enhance_with_documents(extraction, documents)
            
            return extraction
            
        except Exception as e:
            self.logger.error(f"‚ùå Romanian extraction failed: {e}")
            return {'error': str(e), 'country': 'romania'}
    
    def _extract_romanian_title(self, text: str) -> Dict[str, str]:
        """Extract Romanian title with proper diacritic handling."""
        # Look for title patterns in Romanian
        title_patterns = [
            r'(?:TITLU|Titlu|DENUMIRE|Denumire)[:\s]*([^\n]+)',
            r'(?:MƒÇSURA|MƒÉsura|SUBMƒÇSURA|SubmƒÉsura)[:\s]*([^\n]+)',
            r'^([A-ZƒÇ√Ç√é»ò»ö][a-zƒÉ√¢√Æ»ô»õ\s\-‚Äì]{10,80})$'  # Romanian title pattern
        ]
        
        for pattern in title_patterns:
            match = re.search(pattern, text, re.MULTILINE | re.IGNORECASE)
            if match:
                title = match.group(1).strip()
                return {
                    'ro': title,
                    'en': self._translate_to_english(title)  # Would use real translation
                }
        
        return {'ro': 'Titlu nedeterminat', 'en': 'Undetermined title'}
    
    def _extract_financial_info(self, text: str) -> Dict[str, Any]:
        """Extract financial information with RON/EUR handling."""
        financial_info = {}
        
        # Look for Romanian currency patterns
        ron_patterns = [
            r'(\d+(?:\.\d+)?(?:\,\d+)?)\s*(?:lei|RON|ron)',
            r'(?:lei|RON|ron)\s*(\d+(?:\.\d+)?(?:\,\d+)?)',
            r'(\d+(?:\.\d+)?(?:\,\d+)?)\s*milioane\s*(?:lei|RON)',
        ]
        
        eur_patterns = [
            r'(\d+(?:\.\d+)?(?:\,\d+)?)\s*(?:EUR|euro|‚Ç¨)',
            r'(?:EUR|euro|‚Ç¨)\s*(\d+(?:\.\d+)?(?:\,\d+)?)',
        ]
        
        # Extract amounts
        for pattern in ron_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                ron_amount = self._parse_romanian_number(matches[0])
                financial_info['amount_ron'] = ron_amount
                financial_info['amount_eur'] = ron_amount * self.ron_to_eur_rate
                break
        
        for pattern in eur_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                eur_amount = self._parse_romanian_number(matches[0])
                financial_info['amount_eur'] = eur_amount
                break
        
        # Extract co-financing rates
        cofinancing_pattern = r'(?:cofinan»õare|cofinantare)[:\s]*(\d+)%'
        match = re.search(cofinancing_pattern, text, re.IGNORECASE)
        if match:
            financial_info['eu_cofinancing_rate'] = int(match.group(1)) / 100
        
        return financial_info
    
    def _extract_geographic_scope(self, text: str) -> List[str]:
        """Extract Romanian counties (jude»õe) and regions."""
        regions = []
        
        # Look for county names
        for county_code, county_names in self.county_mappings.items():
            for name in county_names:
                if name.lower() in text.lower():
                    regions.append(county_code)
                    break
        
        # Look for regional patterns
        region_patterns = [
            r'(?:jude»õul|judetul)\s+([A-ZƒÇ√Ç√é»ò»ö][a-zƒÉ√¢√Æ»ô»õ]+)',
            r'(?:regiunea|zona)\s+([A-ZƒÇ√Ç√é»ò»ö][a-zƒÉ√¢√Æ»ô»õ\s]+)',
        ]
        
        for pattern in region_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            regions.extend(matches)
        
        return list(set(regions))  # Remove duplicates
    
    def _extract_pndr_specific_info(self, text: str) -> Dict[str, Any]:
        """Extract PNDR-specific information."""
        pndr_info = {}
        
        # Look for PNDR measure codes
        measure_pattern = r'(?:MƒÇSURA|MƒÉsura|SUBMƒÇSURA|SubmƒÉsura)\s+(\d+(?:\.\d+)?)'
        match = re.search(measure_pattern, text)
        if match:
            measure_code = match.group(1)
            pndr_info['measure_code'] = measure_code
            pndr_info['measure_name'] = self.pndr_measure_codes.get(measure_code, 'Unknown measure')
        
        # Look for PNDR references
        pndr_refs = re.findall(r'PNDR\s+(\d{4}-\d{4}|\d{4}-\d{2})', text)
        if pndr_refs:
            pndr_info['pndr_period'] = pndr_refs[0]
        
        return pndr_info
    
    def _initialize_county_mappings(self) -> Dict[str, List[str]]:
        """Initialize Romanian county mappings."""
        return {
            'AB': ['Alba', 'Alba Iulia'],
            'AR': ['Arad'],
            'AG': ['Arge»ô', 'Arges', 'Pite»ôti', 'Pitesti'],
            'BC': ['BacƒÉu', 'Bacau'],
            'BH': ['Bihor', 'Oradea'],
            'BN': ['Bistri»õa-NƒÉsƒÉud', 'Bistrita-Nasaud', 'Bistri»õa', 'Bistrita'],
            'BT': ['Boto»ôani', 'Botosani'],
            'BR': ['BrƒÉila', 'Braila'],
            'BV': ['Bra»ôov', 'Brasov'],
            'BZ': ['BuzƒÉu', 'Buzau'],
            'CL': ['CƒÉlƒÉra»ôi', 'Calarasi'],
            'CS': ['Cara»ô-Severin', 'Caras-Severin'],
            'CJ': ['Cluj', 'Cluj-Napoca'],
            'CT': ['Constan»õa', 'Constanta'],
            'CV': ['Covasna'],
            'DB': ['D√¢mbovi»õa', 'Dambovita', 'T√¢rgovi»ôte', 'Targoviste'],
            'DJ': ['Dolj', 'Craiova'],
            'GL': ['Gala»õi', 'Galati'],
            'GR': ['Giurgiu'],
            'GJ': ['Gorj', 'T√¢rgu Jiu'],
            'HR': ['Harghita', 'Miercurea Ciuc'],
            'HD': ['Hunedoara', 'Deva'],
            'IL': ['Ialomi»õa', 'Ialomita', 'Slobozia'],
            'IS': ['Ia»ôi', 'Iasi'],
            'IF': ['Ilfov'],
            'MM': ['Maramure»ô', 'Maramures', 'Baia Mare'],
            'MH': ['Mehedin»õi', 'Mehedinti', 'Drobeta-Turnu Severin'],
            'MS': ['Mure»ô', 'Mures', 'T√¢rgu Mure»ô', 'Targu Mures'],
            'NT': ['Neam»õ', 'Neamt', 'Piatra Neam»õ', 'Piatra Neamt'],
            'OT': ['Olt', 'Slatina'],
            'PH': ['Prahova', 'Ploie»ôti', 'Ploiesti'],
            'SJ': ['SƒÉlaj', 'Salaj', 'ZalƒÉu', 'Zalau'],
            'SM': ['Satu Mare'],
            'SB': ['Sibiu'],
            'SV': ['Suceava'],
            'TR': ['Teleorman', 'Alexandria'],
            'TM': ['Timi»ô', 'Timis', 'Timi»ôoara', 'Timisoara'],
            'TL': ['Tulcea'],
            'VL': ['V√¢lcea', 'Valcea', 'R√¢mnicu V√¢lcea'],
            'VS': ['Vaslui'],
            'VN': ['Vrancea', 'Foc»ôani', 'Focsani'],
            'B': ['Bucure»ôti', 'Bucuresti', 'Bucharest']
        }
    
    def _initialize_pndr_codes(self) -> Dict[str, str]:
        """Initialize PNDR measure codes and names."""
        return {
            '1': 'Transfer de cuno»ôtin»õe »ôi ac»õiuni de informare',
            '2': 'Servicii de consiliere, servicii de gestionare a exploata»õiei agricole »ôi servicii de √Ænlocuire √Æn cadrul exploata»õiei',
            '3': 'Sisteme de calitate pentru produsele agricole »ôi alimentare',
            '4': 'Investi»õii √Æn active fizice',
            '5': 'Refacerea poten»õialului de produc»õie agricolƒÉ',
            '6': 'Dezvoltarea exploata»õiilor »ôi a √Æntreprinderilor',
            '7': 'Servicii de bazƒÉ »ôi re√Ænnoirea satelor √Æn zonele rurale',
            '8': 'Investi»õii √Æn dezvoltarea zonelor forestiere »ôi √ÆmbunƒÉtƒÉ»õirea viabilitƒÉ»õii pƒÉdurilor',
            '9': '√énfiin»õarea de grupuri de producƒÉtori',
            '10': 'PlƒÉ»õi pentru agricultura ecologicƒÉ',
            '11': 'PlƒÉ»õi pentru zonele care se confruntƒÉ cu constr√¢ngeri naturale sau cu alte constr√¢ngeri specifice',
            '12': 'PlƒÉ»õi Natura 2000 »ôi plƒÉ»õi legate de Directiva-cadru ApƒÉ',
            '13': 'PlƒÉ»õi pentru zonele care se confruntƒÉ cu dezavantaje naturale',
            '14': 'BunƒÉstarea animalelor',
            '15': 'Servicii de silvi-mediu »ôi climatice »ôi conservarea pƒÉdurilor',
            '16': 'Cooperare',
            '19': 'Sprijin pentru dezvoltarea localƒÉ LEADER'
        }
    
    def _initialize_romanian_terms(self) -> Dict[str, str]:
        """Initialize Romanian agricultural terminology mappings."""
        return {
            'exploata»õie agricolƒÉ': 'agricultural holding',
            'fermier': 'farmer',
            'producƒÉtor agricol': 'agricultural producer',
            'cooperativƒÉ agricolƒÉ': 'agricultural cooperative',
            'grup de producƒÉtori': 'producer group',
            '√Æntreprindere micƒÉ »ôi mijlocie': 'small and medium enterprise',
            'zonƒÉ defavorizatƒÉ': 'less favoured area',
            'agriculturƒÉ ecologicƒÉ': 'organic farming',
            'dezvoltare ruralƒÉ': 'rural development',
            'diversificare': 'diversification',
            'inovare': 'innovation',
            'sustenabilitate': 'sustainability',
            'mediu √Ænconjos': 'environment',
            'schimbƒÉri climatice': 'climate change',
            'biodiversitate': 'biodiversity'
        }
    
    def _parse_romanian_number(self, number_str: str) -> float:
        """Parse Romanian number format (comma as decimal separator)."""
        try:
            # Replace comma with dot for decimal parsing
            cleaned = number_str.replace('.', '').replace(',', '.')
            return float(cleaned)
        except ValueError:
            return 0.0
    
    def _translate_to_english(self, romanian_text: str) -> str:
        """Translate Romanian text to English (placeholder)."""
        # In real implementation, would use translation API
        return f"[EN] {romanian_text}"